# Assorti backend demos

## Basicboot

Een kleine CRUD applicatie met een probleem! De shop heeft een langzame query (vanwege de SlowProductRepository, maar
dit soort zaken kunnen in het echt ook spontaan voorkomen). Heel slim heeft men besloten om daarom de data te cachen, en 
daarmee leek het probleem verdwenen... Totdat er meer dan 1 instantie van de service draait.

Het basisidee hierachter zie je ook in de counter. Als je meerdere instanties van de applicatie start, dan zal de counter 
niet synchroon lopen.

Kortom, ook in zeer kleine, onschuldige setups kom je de ellende van gedistribueerde systemen al tegen. In dit geval
hebben we 2 service instances die dezelfde data _cachen_ en dat niet *consistent* doen.

Setup:

1. Start de docker-containers, dan heb je de loadbalancer op http://localhost:8090 draaien, en de admin omgeving op 
   http://localhost:9000/stats.
2. Start één service instance gewoon default uit IntelliJ (poort 8080)
3. Dupliceer de run-configuration en start een tweede instance op poort 8082 (env-variable SERVER_PORT)
4. Postman collectie importeren

Known issues:

* Beide applicaties proberen de database te initializeren... dat moet iets fraaier :S 


## ClientDataRest 

We hebben in BEP2 iedereen mooi geleerd om CRUD APIs te maken. Waarom is dat niet genoeg? Nou omdat zulk soort applicaties
eigenlijk niet geschreven hoeven worden. Er zijn frameworks die dit gewoon voor je genereren. Handig om aan het begin van 
een project het eea. mee te scaffolden zodat je frontenders snel uit de startblokken kunnen.

Uiteraard zullen de urls nog een beetje veranderen naarmate je dit scaffold vervangt met je eigen code, maar je frontenders
hebben geleerd hun fetches achter een architectureel laagje te stoppen... toch?

Setup:

1. Gewoon starten, daarna surfen naar http://localhost:8080

Known issues:

* Staat for some reason in de RPC folder...

## DDD-Example

Dit example was letterlijk de exercise, dus die moet overnieuw.

Known issues:

* Moet overnieuw;)

## Bad-Aggregate

Bad-Aggregate is 'inspired by a true story'. Het issue is dat een Question een Aggregate is, die altijd z'n eigen state moet
bewaken. Maar dat doet ie niet. De entity muteert zichzelf om de juiste taal aan te nemen.

Dit *was* nooit een probleem, totdat een ander featurerequest iets van de client moest bijhouden (welke pagina het laatst bezocht was).
Toen werd er een @Transactional stuk ergens in het proces gezet, en werden ineens die ongerelateerde aggregate-changes geflushed.

Kortom behandel je entities altijd alsof ze elk moment opgeslagen kunnen worden, want dat is feitelijk de service die JPA biedt.
(en overal repo.save aanroepen is 90% van de tijd nergens voor nodig)

Known issues:

* Staat for some reason in de NoSQL folder...
* Moet eigenlijk ook een ID-gen demootje erbij (Sequence vs. Autogenerated)

## Kanye-Rustiger

Essentie van de Demo hier is een voorbeeld van netjes encapsuleren van externe dependencies (Hexagonal Architecture). Dit
stelt je ook in staat om de API te developen zonder gebruik te maken van de externe service.

(in principe bouw ik deze demo op 'from scratch')


## Messaging-Patterns

Korte demo van verschillende manieren om met RabbitMQ te werken. De timing is nog een beetje tricky, komt dit te vroeg? te laat?